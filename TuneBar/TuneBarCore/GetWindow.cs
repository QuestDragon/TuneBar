using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Automation;

namespace TuneBar
{
    internal class GetWindow
    {
        // Generated By ChatGPT 4o

        // ウィンドウの列挙
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

        // ウィンドウのタイトルを取得
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

        // ウィンドウが表示されているか確認
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsWindowVisible(IntPtr hWnd);

        // ウィンドウが最小化されているか確認
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);

        // ウィンドウのプロセスIDを取得
        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

        private static WindowHandle_Data window_items = new(); //独自クラス。(ウィンドウハンドル : (ウィンドウタイトル、プロセス名))の3つの要素を保持する。
        public static WindowHandle_Data full_window_items = new(); //Form2で使用する。
        private static bool Progress_Handler = false;
        public static bool DetectedNewWindow = false;
        public static IntPtr host_windowID = (IntPtr)0; //AudioをならすきっかけになっているウィンドウのID
        public static string host_window_proc = ""; //とプロセス名（Form2で使用）

        /// <summary>
        /// 開いているウィンドウの情報を返します。
        /// </summary>
        /// <returns>Window_Items。</returns>
        public static WindowHandle_Data GetWindow_Datas()
        {
            return full_window_items;
        }

        /// <summary>
        /// 開いているWindowを検査し、Audio操作を行います。
        /// </summary>
        public static async void Window_Handler()
        {
            //実行中の間は呼び出しに応答しない。
            if (Progress_Handler)
            {
                Debug.WriteLine("Window_Handler is progressing...");
                return;
            } 

            Progress_Handler = true; //呼び出しをロック。
            window_items = new(); //Init

            bool playable = false;
            int window_count = 0;
            SettingsData settings = Serializer.Deserialize();

            // EnumWindowsでウィンドウを列挙 - システム内のすべてのトップレベルウィンドウを列挙します。
            EnumWindows(new EnumWindowsProc(EnumWindowCallback), IntPtr.Zero);

            full_window_items = window_items; //調整前のWindowItemsを保存

            #region 取得したウィンドウリストを設定データに基づいて調整

            if (!settings.exp_only) //Explorerにしか反応させない設定でない場合（Exp設定の場合はいちいち精査する必要がないため）
            {                
                foreach (var item in window_items.WHD.Keys) //まずはハンドルIDを順番に取得
                {
                    Window_Data wd = window_items.WHD[item]; //該当のWindow_Dataを取得

                    if(settings.TargetList.Count > 0) //Target Listが優先
                    {
                        if (!settings.TargetList.Contains(wd.ProcName.ToLower())) //プロセス名で検索
                        {
                            //含まない場合は削除
                            Debug.WriteLine("Not target - Remove: " + wd.ProcName);
                            window_items.WHD.Remove(item);
                        }
                    }
                    else // Ignore Listをもとにリストからウィンドウを除外する
                    {
                        if (settings.IgnoreList.Contains(wd.ProcName.ToLower())) //プロセス名で検索
                        {
                            //含まれる場合は削除
                            Debug.WriteLine("Ignore: " + wd.ProcName);
                            window_items.WHD.Remove(item);
                        }
                    }

                }
            }

            #endregion

            Debug.WriteLine("WindowTitles count: " + window_items.WHD.Count);

            if (window_items.WHD.ContainsKey((int)host_windowID)) //きっかけのウィンドウハンドルIDがまだある場合（動作高速化）
            {
                Debug.WriteLine($"Checking: {window_items.WHD[(int)host_windowID].Title} (host)"); //そのウィンドウにプログレスバーがまだ存在するか確認
                if (await GetProgressBar_Async(host_windowID) == true)
                {
                    Debug.WriteLine("Progress bar processing ongoing, continue playing!");
                    Form1.sc.AudioPlay(!settings.dont_duplicate); //再生要求

                    Progress_Handler = false; //呼び出し可能
                    return;
                }
            }
            // きっかけのウィンドウがなくなった場合は停止して再度全スキャン
            Debug.WriteLine("Stop the music and start a full scan!!");
            Form1.sc.AudioStop();
            host_windowID = (IntPtr)0; //きっかけのウィンドウをなしにする
            host_window_proc = "";

            if (settings.exp_only) //Explorerにしか反応させない場合
            {
                foreach(var item in window_items.WHD.Keys) //まずはハンドルIDを順番に取得
                {
                    Window_Data wd = window_items.WHD[item]; //該当のWindow_Dataを取得

                    if(wd.ProcName == "explorer") //プロセス名で検索
                    {
                        if (await GetProgressBar_Async((IntPtr)item) == true) //プログレスバーを検索
                        {
                            Debug.WriteLine("Discovered the Explorer progress bar! AudioPlay!!");
                            host_windowID = (IntPtr)item; //きっかけのウィンドウIDを保存
                            host_window_proc = wd.ProcName; //プロセス名も保存
                            playable = true;
                            Form1.sc.AudioPlay(!settings.dont_duplicate); //他再生中にならさないがTrueのときは値が反転してForcePlayがFalseになる。
                            break;
                        }
                    }
                }
            }
            else //それ以外（プログレスバーのあるウィンドウを検索）
            {
                foreach (int handleID in window_items.WHD.Keys)
                {
                    bool new_window = false;

                    if (DetectedNewWindow)
                    {
                        new_window =  await New_Window_Handler();
                        playable = new_window; //再生できるかの結果を保存
                    }

                    if (!new_window) //新たなウィンドウがない、またはプログレスバーを有していない場合はループ続行
                    {
                        string title = window_items.WHD[handleID].Title;

                        window_count++;
                        Debug.WriteLine($"Checking: {title} <{handleID}> ({window_count})");

                        if(title == "TuneBar")
                        {
                            continue; //自分自身の場合はチェックにかけない
                        }

                        if (await GetProgressBar_Async((IntPtr)handleID) == true)
                        {
                            Debug.WriteLine("Let's go! AudioPlay!!");
                            host_windowID = (IntPtr)handleID; //きっかけのウィンドウIDを保存
                            host_window_proc = window_items.WHD[handleID].ProcName; //プロセス名も保存
                            playable = true;
                            Form1.sc.AudioPlay(!settings.dont_duplicate); //他再生中にならさないがTrueのときは値が反転してForcePlayがFalseになる。
                            break;
                        }
                    }
                    else //新たなウィンドウがホストになった場合はForeachを抜ける
                    {
                        break;
                    }
                }
            }


            Debug.WriteLine("[Window_Handler] Playable: " + playable);
            Form2.Update_StripLabel();

            // プログレスバーがない場合は再生停止
            if (!playable)
            {
                Debug.WriteLine("It's not playable! AudioStop!!");
                Form1.sc.AudioStop();
            }

            Progress_Handler = false; //呼び出し可能

        }

        /// <summary>
        /// 新たに生成されたウィンドウに対し、プログレスバーの有無を判断します。
        /// </summary>
        /// <returns>プログレスバーの有無</returns>
        private static async Task<bool> New_Window_Handler()
        {
            if (!DetectedNewWindow)
            {
                Debug.WriteLine("It seems that NWH was called by mistake. I'm going to close...");
                DetectedNewWindow = false;
                return false;
            }

            DetectedNewWindow = false;
            bool ret = false;

            IntPtr HandleID = (IntPtr)GetNewWindow.New_Window_HandleID;

            // ウィンドウのタイトルを取得 - ウィンドウが現在表示されているかどうかを確認します。これにより、隠れたウィンドウやシステム関連のウィンドウをフィルタリングします。
            string windowTitle = GetNewWindow.New_Window_Name;

            // GetWindowThreadProcessId: ウィンドウに関連するプロセスIDを取得し、それに基づいてプロセス名を取得します。
            uint processId;
            GetWindowThreadProcessId(HandleID, out processId);
            Process process = Process.GetProcessById((int)processId);

            Debug.WriteLine($"Checking new window: {windowTitle} <{HandleID}>");

            if (await GetProgressBar_Async(HandleID) == true) //プログレスバーチェック
            {
                SettingsData settings = Serializer.Deserialize();
                Debug.WriteLine("[NWH] Let's go! AudioPlay!!");
                host_windowID = HandleID; //きっかけのウィンドウIDを保存
                host_window_proc = process.ProcessName; //プロセス名も保存
                Form1.sc.AudioPlay(!settings.dont_duplicate); //他再生中にならさないがTrueのときは値が反転してForcePlayがFalseになる。
                ret = true;
            }

            return ret;
        }

        /// <summary>
        /// 音楽を再生するきっかけになっているウィンドウIDとプロセス名を返します。
        /// </summary>
        /// <returns>プロセス名 (ウィンドウID)</returns>
        public static string GetHostWindowInfo()
        {
            string res = "";

            if (SoundCore.IsPlaySound) //再生中の場合
            {
                if(host_window_proc != "" && host_windowID != (IntPtr)0) //プロセス名とIDが正しく保存されている場合
                {
                    res = $"{host_window_proc}.exe ({host_windowID})"; //はじめて情報を書き込む
                }
                else //プロセス名やIDがない場合は強制再生中
                {
                    res = "Force playing";
                }
            }

            return res ;
        }

        // ウィンドウ列挙のコールバック ※新しく開かれたウィンドウに対しての反応が遅すぎる！！新たなウィンドウが出たら即そのウィンドウを検査する勢いで！！
        private static bool EnumWindowCallback(IntPtr hWnd, IntPtr lParam)
        {
            // ウィンドウが表示されている、または最小化されているかを確認
            if (IsWindowVisible(hWnd) || IsIconic(hWnd))
            {
                // ウィンドウのタイトルを取得 - ウィンドウが現在表示されているかどうかを確認します。これにより、隠れたウィンドウやシステム関連のウィンドウをフィルタリングします。
                StringBuilder windowTitle = new StringBuilder(256);
                GetWindowText(hWnd, windowTitle, windowTitle.Capacity);

                // ウィンドウのタイトルが空でない場合に処理
                if (windowTitle.Length > 0)
                {
                    uint processId;
                    // GetWindowThreadProcessId: ウィンドウに関連するプロセスIDを取得し、それに基づいてプロセス名を取得します。
                    GetWindowThreadProcessId(hWnd, out processId);
                    Process process = Process.GetProcessById((int)processId);

                    // Chrome Fixが有効の場合はForeach自体にかけないようにするためにここで排除
                    SettingsData settings = Serializer.Deserialize();
                    if (settings.chrome_fix) //Chromeのプログレスバーチェックにより、Chromeの動作が重くなる場合の解決機能
                    {
                        if (windowTitle.ToString().Contains("Google Chrome"))
                        {
                            Debug.WriteLine("Google Chrome detected. Skipping...");
                            return true;  //処理スキップ、次のウィンドウへ
                        }
                    }

                    // IsIconic: ウィンドウが最小化されているかどうかを確認します。
                    // Debug.WriteLine($"ウィンドウタイトル: {windowTitle}, プロセス名: {process.ProcessName}, 最小化: {IsIconic(hWnd)}");
                    window_items.WHD.Add((int)hWnd, new Window_Data(windowTitle.ToString(),process.ProcessName)); // ウィンドウに対して一意のHandleIDとウィンドウタイトル、プロセス名を登録
                }
            }
            return true;
        }

        /// <summary>
        /// GetProgressBarを実行します。
        /// </summary>
        /// <param name="Win_ID">プログレスバーの有無を調べたいウィンドウのハンドルIDを入力します。</param>
        /// <returns>プログレスバーを保有しているかどうか。</returns>
        private static async Task<bool> GetProgressBar_Async(IntPtr Win_ID)
        {
            // タイムアウトの秒数を設定
            int timeout = 2;

            // タスク1: プログレスバーを取得する
            var task1 = Task.Run(() => GetProgressBar(Win_ID));

            // タスク2: タイムアウトをシミュレートする
            var task2 = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromSeconds(timeout)); // 遅延を挿入(タイムアウト時間)
                Debug.WriteLine("タイムアウトしました。Falseを返します…。");
                return false; // タイムアウトした場合はfalseを返す
            });

            // 先に完了したタスクを待つ
            var completedTask = await Task.WhenAny(task1, task2);

            // 完了したタスクの結果を返す
            return await completedTask;
        }

        /// <summary>
        /// プログレスバーの有無を調べます。（結果が分かるまで実行し続けるため、Async側から実行して下さい）
        /// </summary>
        /// <param name="windowID">プログレスバーを調べたいウィンドウのハンドルIDを入力します。</param>
        /// <returns>プログレスバーを保有しているかどうか。</returns>
        static bool GetProgressBar(IntPtr windowID)
        {
            bool res = false;

            // ウィンドウのタイトル（ここに確認したいウィンドウのタイトルを入力）
            // string windowTitle = "Progress Window";

            // 対象ウィンドウの AutomationElement を取得
            // AutomationElement window = GetWindowByTitle(windowTitle); Explorerのコピーダイアログに対応できないので却下
            AutomationElement window;

            try
            {
                 window = AutomationElement.FromHandle(windowID);
            }
            catch (ElementNotAvailableException)
            {
                Debug.WriteLine("ウィンドウの取得に失敗しました。");
                return res;
            }

            if (window == null)
            {
                Debug.WriteLine("ウィンドウが見つかりませんでした。");
                return res;
            }

            // プログレスバーを検索
            AutomationElement progressBar = window.FindFirst(TreeScope.Descendants,
                new PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.ProgressBar));

            if (progressBar != null)
            {
                // ウィンドウのタイトルを取得 - ウィンドウが現在表示されているかどうかを確認します。これにより、隠れたウィンドウやシステム関連のウィンドウをフィルタリングします。
                StringBuilder windowTitle = new StringBuilder(256);
                GetWindowText(windowID, windowTitle, windowTitle.Capacity);

                Debug.WriteLine($"{windowTitle} にてプログレスバーが見つかりました。");

                // プログレスバーの現在値を取得
                object valuePatternObj;
                if (progressBar.TryGetCurrentPattern(ValuePattern.Pattern, out valuePatternObj))
                {
                    ValuePattern valuePattern = (ValuePattern)valuePatternObj;
                    Debug.WriteLine("プログレスバーの現在の値: " + valuePattern.Current.Value);
                }
                else
                {
                    Debug.WriteLine("プログレスバーの値を取得できませんでした。");
                }

                res = true; //値取得はできてなくてもOK（現状は。）
            }
            else
            {
                Debug.WriteLine("プログレスバーが見つかりませんでした。");
            }

            Debug.WriteLine("最終判定：" + res);

            return res;
        }


        // ウィンドウタイトルから AutomationElement を取得 →現在は使用していない
        static AutomationElement GetWindowByTitle(string title)
        {
            return AutomationElement.RootElement.FindFirst(TreeScope.Children,
                new PropertyCondition(AutomationElement.NameProperty, title));
        }
    }

    /// <summary>
    /// ハンドルIDとWindow_Dataを格納するクラス
    /// </summary>
    class WindowHandle_Data
    {
        //Dictionary型のメソッドやプロパティを呼び出し元で使う場合はPublicを、
        //このクラスで用意した専用メソッドを使ってDictionaryを操作する場合はPrivateにする。
        public Dictionary<int, Window_Data> WHD;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public WindowHandle_Data()
        {
            WHD = new Dictionary<int, Window_Data>();
        }
    }

    /// <summary>
    /// ウィンドウタイトルとプロセス名を格納するクラス
    /// </summary>
    class Window_Data
    {
        
        public string Title { get; set; }
        public string ProcName { get; set; }

        // コンストラクタ。New式でこのクラスを呼び出した際、引数の内容が自動で格納されてインスタンスが作成される処理。
        public Window_Data(string WindowTitle,string ProcessName)
        {
            Title = WindowTitle;
            ProcName = ProcessName;
        }
    }
}
